<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
body {
  font-family: "Lato", sans-serif;
}

.sidenav {
  height: 100%;
  width: 200px;
  position: fixed;
  z-index: 1;
  top: 0;
  left: 0;
  background-color: #111;
  overflow-x: hidden;
  padding-top: 20px;
}

.sidenav a {
  padding: 6px 8px 6px 16px;
  text-decoration: none;
  /*font-size: 16px;*/
  color: #f1f111;
  display: block;
}

.sidenav a:hover {
  color: #f111f1;
}

.main {
  margin-left: 200px; /* Same as the width of the sidenav */
  /*font-size: 28px;  Increased text to enable scrolling */
  padding: 0px 10px;
}

@media screen and (max-height: 450px) {
  .sidenav {padding-top: 15px;}
  .sidenav a {font-size: 18px;}
}
</style>
<title>可编程科学计算器帮助</title>
</head>
<body>

<div class="sidenav">
<p style="font-size:18px;"><a href="../../en/MFPIndex.html">[English Version]</a></p>
	<p style="font-size:18px;"><a href="../MFPIndex.html">MFP语言和可编程科学计算器</a></p>
	<p style="font-size:15px;"><a href="../LanguageInfo/language.html">MFP语言简介</a></p>
	<p style="font-size:15px;"><a href="../FunctionInfo/functions.html">MFP函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/all.html">所有函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/integer_operation.html">整数操作函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/logic.html">逻辑函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/statistic_and_stochastic.html">统计和随机函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/trigononmetric.html">三角函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/exponential_and_logarithmic.html">指数函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/complex_number.html">复数函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/system.html">系统函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/array_or_matrix.html">数组和矩阵函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/graphic.html">绘图函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/expression_and_calculus.html">表达式和微积分函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/string.html">字符串函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/hyperbolic_trigononmetric.html">双曲三角函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/sorting.html">排序函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/polynomial.html">多项式函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/signal_proc.html">信号处理函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/file.html">文件操作函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/time_and_date.html">时间和日期函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/gdi.html">显示函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/multimedia.html">多媒体函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/datastruct.html">数据结构函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/exdata.html">数据交换文件格式函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/platform_hardware.html">平台和硬件函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/parallel.html">并行计算函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/rtcmmedia.html">RTC多媒体函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/reflection.html">反射函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/mfpcompiler.html">MFP编译函数</a></p>
	<p style="font-size:12px;"><a href="../FunctionInfo/others.html">其它函数</a></p>
	<p style="font-size:15px;"><a href="../HowtoInfo/deploy_user_functions.html">部署用户自定义函数</a></p>
	<p style="font-size:15px;"><a href="../HowtoInfo/use_mfp_android_lib.html">在您的应用中调用MFP</a></p>
	<p style="font-size:15px;"><a href="../HowtoInfo/build_apk.html">创建安卓安装包</a></p>
	<p style="font-size:15px;"><a href="../GameProgramming/index.html">小游戏的开发</a></p>
	<p style="font-size:15px;"><a href="../ChartPlotting/index.html">绘制图形</a></p>
	<p style="font-size:15px;"><a href="../MathFunctions/math_functions.html">使用MFP进行数学分析</a></p>
	<p style="font-size:15px;"><a href="../FileOperation/file_operation.html">使用MFP处理文件</a></p>
	<p style="font-size:15px;"><a href="../NumberStrArray/number_str_array.html">数，字符串和数组</a></p>
	<p style="font-size:15px;"><a href="../TimeDateSysFuncs/time_date_sys_functions.html">日期时间和系统相关</a></p>
	<p style="font-size:15px;"><a href="../SCPIntro/tutorial_4_scp_users.html">可编程科学计算器介绍</a></p>
<p/><p/><p/></div>

<div class="main">
<h2 style="color:blue">可编程科学计算器帮助：数组和矩阵函数</h2>
<table border="1" style="font-family:times;color:green;">
<tr>
<th>函数名</th>
<th>函数帮助信息</th>
</tr>
<tr>
<td><center>adj</center></td>
<td><p>::mfp::math::matrix::adj(1) :</p>
<p>函数cofactor(x)返回2维方阵x的伴随矩阵。</p>
</td>
</tr>
<tr>
<td><center>alloc_array</center></td>
<td><p>::mfp::array::alloc_array(1...) :</p>
<p>alloc_array(x...)返回一个新分配的矩阵，其大小由参数决定。所有的参数都必须为正整数。</p>
<p>::mfp::array::alloc_array(2) :</p>
<p>alloc_array(x, y)返回一个新分配的矩阵，其大小由正整数数列参数x决定。参数y是矩阵中所有元素的初始值，注意y参数可省略，如果省略，所有元素被初始化为0。</p>
</td>
</tr>
<tr>
<td><center>cofactor</center></td>
<td><p>::mfp::math::matrix::cofactor(1) :</p>
<p>函数cofactor(x)返回2维方阵x的余因子矩阵。</p>
</td>
</tr>
<tr>
<td><center>det</center></td>
<td><p>::mfp::math::matrix::det(1) :</p>
<p>det(x)计算2维方阵x的行列式值。</p>
</td>
</tr>
<tr>
<td><center>deter</center></td>
<td><p>::mfp::math::matrix::deter(1) :</p>
<p>deter(x)计算2维方阵x的行列式值。</p>
</td>
</tr>
<tr>
<td><center>dprod</center></td>
<td><p>::mfp::math::matrix::dprod(2) :</p>
<p>函数dprod用于计算两个向量 [x1, x2, ... xn]和[y1, y2, ... yn]的点乘值。</p>
</td>
</tr>
<tr>
<td><center>eig</center></td>
<td><p>::mfp::math::matrix::eig(1) :</p>
<p>eig(A)计算2维方阵A的特征向量和特征值。这个函数返回一个包含两个成员的列表。第一个成员是特征向量矩阵，每一列是一个特征向量。第二个成员是一个对角矩阵，每一个对角线元素是一个特征值。注意运算这个函数非常耗费内存和CPU资源，如果在手机上运行，矩阵A的尺寸最好不要超过6*6，如果在电脑上运行，最好不要超过8*8，否则可能造成内存不足而程序崩溃或者运行很长时间而没有结果。</p>
<p>::mfp::math::matrix::eig(2) :</p>
<p>eig(A, B)计算2维方阵A相对于同样尺寸的方阵B的特征向量和特征值，也就是Av = lambda * Bv，在这里，。lambda是一个特征值，v是一个特征向量。第二个参数，B，可以省略，其缺省值为I矩阵。这个函数返回一个包含两个成员的列表。第一个成员是特征向量矩阵，每一列是一个特征向量。第二个成员是一个对角矩阵，每一个对角线元素是一个特征值。注意运算这个函数非常耗费内存和CPU资源，如果在手机上运行，矩阵A的尺寸最好不要超过6*6，如果在电脑上运行，最好不要超过8*8，否则可能造成内存不足而程序崩溃或者运行很长时间而没有结果。</p>
</td>
</tr>
<tr>
<td><center>eye</center></td>
<td><p>::mfp::math::matrix::eye(1) :</p>
<p>eye(x)返回正整数x乘x的2维方阵I。注意表达式eye(0)返回常数1。</p>
<p>::mfp::math::matrix::eye(2) :</p>
<p>eye(x,y)返回y（y为正整数）维方阵I，注意每一维长度均为正整数x。</p>
</td>
</tr>
<tr>
<td><center>get_eigen_values</center></td>
<td><p>::mfp::math::matrix::get_eigen_values(1) :</p>
<p>get_eigen_values(A)计算2维方阵A的特征值。这个函数返回所有特征值，包括重复的特征值的列表。注意运算这个函数非常耗费内存和CPU资源，如果在手机上运行，矩阵A的尺寸最好不要超过6*6，如果在电脑上运行，最好不要超过8*8，否则可能造成内存不足而程序崩溃或者运行很长时间而没有结果。</p>
<p>::mfp::math::matrix::get_eigen_values(2) :</p>
<p>get_eigen_values(A, B)计算2维方阵A相对于同样尺寸的方阵B的特征值，也就是Av = lambda * Bv，在这里，。lambda是一个特征值，v是一个特征向量。第二个参数，B，可以省略，其缺省值为I矩阵。这个函数返回所有特征值，包括重复的特征值的列表。注意运算这个函数非常耗费内存和CPU资源，如果在手机上运行，矩阵A的尺寸最好不要超过6*6，如果在电脑上运行，最好不要超过8*8，否则可能造成内存不足而程序崩溃或者运行很长时间而没有结果。</p>
</td>
</tr>
<tr>
<td><center>get_extreme_elem</center></td>
<td><p>::mfp::array::get_extreme_elem(3) :</p>
<p>函数get_extreme_elem分析输入的数值矩阵并返回其所有元素的最大或最小值。如果某一个元素不是实数，这个元素就会被忽略。这个函数有3个参数，第一个是数值矩阵（也可以是一个单一的数值），第二个是起始的最大或者最小值，如果这个参数不是null并且是一个实数，本函数将该参数和选出的最大或最小元素进行比较，并返回新的最大或最小值。第三个参数是告诉本函数返回最大值还是最小值，如果是0则返回最小值，否则返回最大值。函数的例子包括get_extreme_elem([[2, 3], "hello", 5], null, 1)和get_extreme_elem([[3,4,6],[5+3i, 7, 9.88-4.61], [5.77 -0.03i]], -8, 0)。</p>
</td>
</tr>
<tr>
<td><center>includes_inf</center></td>
<td><p>::mfp::array::includes_inf(1) :</p>
<p>includes_inf(x)用于判断参数x是否包含正负无穷。这里，包含指的是，如果x是个数组，那么它的某一个元素包含或者本身就是目标值，如果x是一个复数，那么它的实部或者虚部是目标值，如果x是一个实数，那么它就是目标值。如果是，返回true，否则，返回false。</p>
</td>
</tr>
<tr>
<td><center>includes_nan</center></td>
<td><p>::mfp::array::includes_nan(1) :</p>
<p>includes_nan(x)用于判断参数x是否包含Nan。这里，包含指的是，如果x是个数组，那么它的某一个元素包含或者本身就是目标值，如果x是一个复数，那么它的实部或者虚部是目标值，如果x是一个实数，那么它就是目标值。如果是，返回true，否则，返回false。</p>
</td>
</tr>
<tr>
<td><center>includes_nan_or_inf</center></td>
<td><p>::mfp::array::includes_nan_or_inf(1) :</p>
<p>includes_nan_or_inf(x)用于判断参数x是否包含Nan或者正负无穷。这里，包含指的是，如果x是个数组，那么它的某一个元素包含或者本身就是目标值，如果x是一个复数，那么它的实部或者虚部是目标值，如果x是一个实数，那么它就是目标值。如果是，返回true，否则，返回false。</p>
</td>
</tr>
<tr>
<td><center>includes_nan_or_inf_or_null</center></td>
<td><p>::mfp::array::includes_nan_or_inf_or_null(1) :</p>
<p>includes_nan_or_inf_or_null(x)用于判断参数x是否包含Nan或者正负无穷或者null。这里，包含指的是，如果x是个数组，那么它的某一个元素包含或者本身就是目标值，如果x是一个复数，那么它的实部或者虚部是目标值，如果x是一个实数，那么它就是目标值。如果是，返回true，否则，返回false。</p>
</td>
</tr>
<tr>
<td><center>includes_null</center></td>
<td><p>::mfp::array::includes_null(1) :</p>
<p>includes_null(x)用于判断参数x是否包含null。这里，包含指的是，如果x是个数组，那么它的某一个元素包含或者本身就是目标值，如果x是一个复数，那么它的实部或者虚部是目标值，如果x是一个实数，那么它就是目标值。如果是，返回true，否则，返回false。</p>
</td>
</tr>
<tr>
<td><center>invert</center></td>
<td><p>::mfp::math::matrix::invert(1) :</p>
<p>invert(x)返回方块2维矩阵x的逆矩阵，注意x中的元素可以为复数。</p>
</td>
</tr>
<tr>
<td><center>is_eye</center></td>
<td><p>::mfp::math::matrix::is_eye(2) :</p>
<p>is_eye(x,y)用于确定数组（或数）x是否是单位阵I（或数字1），如果是，返回true，否则返回false。参数y是布尔量，可以省略，缺省值为false。如果y是true，将所有的null值视为0，否则，null值不被当作0。</p>
</td>
</tr>
<tr>
<td><center>is_zeros</center></td>
<td><p>::mfp::math::matrix::is_zeros(2) :</p>
<p>is_zeros(x,y)用于确定数组（或数）x是否是零矩阵（或数字0），如果是，返回true，否则返回false。参数y是布尔量，可以省略，缺省值为false。如果y是true，将所有的null值视为0，否则，null值不被当作0。</p>
</td>
</tr>
<tr>
<td><center>left_recip</center></td>
<td><p>::mfp::math::matrix::left_recip(1) :</p>
<p>left_recip(x)计算x的左除倒数，注意当前仅支持数值或二维矩阵。</p>
</td>
</tr>
<tr>
<td><center>ones</center></td>
<td><p>::mfp::math::matrix::ones(1...) :</p>
<p>ones函数返回一个所有元素都是1的矩阵，本函数的参数用于决定矩阵的尺寸，要么为一批正整数，要么为一个正整数数列。注意函数表达式ones([])返回常数1。</p>
</td>
</tr>
<tr>
<td><center>rank</center></td>
<td><p>::mfp::math::matrix::rank(1) :</p>
<p>rank(matrix)返回矩阵的秩。比如，rank([[1,2],[2,4]])将返回1。</p>
</td>
</tr>
<tr>
<td><center>recip</center></td>
<td><p>::mfp::math::matrix::recip(1) :</p>
<p>recip(x)计算x的倒数，注意当前仅支持数值或二维矩阵。</p>
</td>
</tr>
<tr>
<td><center>set_array_elem</center></td>
<td><p>::mfp::array::set_array_elem(3) :</p>
<p>set_array_elem(x,y,z)将x[y]赋值为z，并且返回新的x。注意x不是必须为矩阵，y必须为正整数向量。y的值可以超出x的尺寸和维度。比如，如果x=3，y=[1,2]，z=2+3i，那么set_array_elem(x,y,z)等于[3, [0, 0, 2+3i]]。还要注意，调用了set_array_elem函数之后，x的值可能会自动变为新值，也可能不会。所以，必须将set_array_elem的返回值赋予x，以保证x的值得到更新。</p>
</td>
</tr>
<tr>
<td><center>size</center></td>
<td><p>::mfp::array::size(1) :</p>
<p>size(x)返回矩阵x的尺寸向量。注意如果x不是一个矩阵，则总是返回[]。</p>
<p>::mfp::array::size(2) :</p>
<p>size(x,y)返回矩阵x前y维的尺寸向量，如果x少于y维，返回完整的尺寸向量，注意y必须为正整数。此外如果x不是一个矩阵，则总是返回[]。</p>
</td>
</tr>
<tr>
<td><center>upper_triangular_matrix</center></td>
<td><p>::mfp::math::matrix::upper_triangular_matrix(1) :</p>
<p>upper_triangular_matrix(x)返回二维方阵x在LU分解之后的上三角矩阵。</p>
</td>
</tr>
<tr>
<td><center>zeros</center></td>
<td><p>::mfp::math::matrix::zeros(1...) :</p>
<p>zeros函数返回一个所有元素都是0的矩阵，本函数的参数用于决定矩阵的尺寸，要么为一批正整数，要么为一个正整数数列。注意函数表达式zeros([])返回常数值0。</p>
</td>
</tr>
</table>
</div>
   
</body>
</html>